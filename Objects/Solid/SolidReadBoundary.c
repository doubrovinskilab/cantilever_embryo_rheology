#ifndef SolidReadBoundary_C
#define SolidReadBoundary_C

PetscErrorCode SolidReadBoundary(System_Struct *system, Solid_Struct *solid)
{
  // Reads a Boundary information variable for Fluid from an input file
  PetscErrorCode ierr;
  char **data;
  char str_boundary[256]="";
  char str_value[256]="";
  PetscBool flg_nb, flg_fa, flg_fi, flg_df, flg_ds, flg_fs, flg_sym, flg_fse, flg_dse, flg_dsxly, flg_af, flg_fae;
  PetscInt n, j, g, N = 0;
  PetscScalar value;

  // Reads a Boundary information variable for Solid points from an input file

  if (solid->N_bound != (solid->N_bound_pts + solid->N_bound_lns + solid->N_bound_trs) ){
    PetscErrorPrintf("The defined number of solid boundary N_bound=%i are not consistent N_bound_pts=%i, N_bound_lns=%i, N_bound_trs=%i\n",
      solid->N_bound, solid->N_bound_pts, solid->N_bound_lns, solid->N_bound_trs);
    SETERRABORT(PETSC_COMM_WORLD,PETSC_ERR_ARG_WRONG,"Error! Incorrect boundary number in solid");  }

  if (solid->N_bound > 0)
  {
    PetscPrintf(PETSC_COMM_WORLD,"Reading solid boundary information\n");

    PetscStrcpy(str_boundary,"Boundary_S"); 
    N = SearchInputAsciiFileForNumberOfOccurances(system->SYSInputFile, str_boundary);

    if (N != solid->N_Gr)  {
      PetscErrorPrintf("The number of groups for solid in InputFile for '%s' is %d is different from the number of groups in the mesh file which is %i\n",
      str_boundary,  N, solid->N_Gr);
      SETERRABORT(PETSC_COMM_WORLD,PETSC_ERR_ARG_WRONG,"Error! number of groups in InputFile");  }

    for (n=0; n<N; n++)
    {
      SearchInputAsciiFileForNthOccurance(system->SYSInputFile, str_boundary, str_value, n);
      PetscStrToArray(str_value,',',&j, &data);

      ierr = PetscOptionsStringToInt(data[0], &g); CHKERRQ(ierr);
      PetscStrcmp(data[1], "nb",    &flg_nb);   // NO SOLID BOUNDARY 
      PetscStrcmp(data[1], "fa",    &flg_fa);   // FORCE ADD BOUNDARY (F += Fb)
      PetscStrcmp(data[1], "fi",    &flg_fi);   // FORCE INSERT BOUNDARY (F = Fb)
      PetscStrcmp(data[1], "df",    &flg_df);   // DISTANCE FIXED BOUNDARY (x = xb, y=yb, z=zb)
      PetscStrcmp(data[1], "ds",    &flg_ds);   // DISTANCE SPEED BOUNDARY (x += Ub*dt, y += Vb*dt, z += Wb*dt)
      PetscStrcmp(data[1], "dsxly", &flg_dsxly);// DISTANCE SPEED X BOUNDARY AS A LINEAR FUNCTION IN Y (x += Ub(y)*dt where Ub(y) = A*y+B)
      PetscStrcmp(data[1], "fs",    &flg_fs);   // FORCE SPEED BOUNDARY (x = Fb & Fb= K*Ub*dt)
      PetscStrcmp(data[1], "sym",   &flg_sym);  // SYMMETRY
      PetscStrcmp(data[1], "fse",   &flg_fse);  // FORCE SPEED ELLIPSE BOUNDARY
      PetscStrcmp(data[1], "dse",   &flg_dse);  // DISTANCE SPEED ELLIPSE BOUNDARY (Theta += dt*DTheta/Dt)
      PetscStrcmp(data[1], "af",    &flg_af);   // FIX THE POSITION OF ONE AXIS (Always the others to move)
      PetscStrcmp(data[1], "fae",   &flg_fae);  // FORCE ADD ELLIPSE BOUNDARY

      if (flg_nb) // NO_SOLID_BC (Nothing)
      { 
        solid->Gr_type[g] = NO_SOLID_BC;
        if (j!= 2){
          PetscErrorPrintf("Number of inputs for solid boundary %s, for group %d should be 2 not %d\n", SOLID_BC_TYPE_CHAR[solid->Gr_type[g]], g, j);
          SETERRABORT(PETSC_COMM_WORLD,PETSC_ERR_ARG_WRONG,"Error! Wrong number of inputs.");}
        solid->Gr_value[g][0] = 0.0;
        solid->Gr_value[g][1] = 0.0;
        solid->Gr_value[g][2] = 0.0;
        PetscPrintf(PETSC_COMM_WORLD,"  Solid boundary group %d: %s\n", g, SOLID_BC_TYPE_CHAR[solid->Gr_type[g]]);
      }
      else if (flg_fa) // FORCE_ADD (Adds a boundary force in addition to the force generated by the system)
      { 
        solid->Gr_type[g] = FORCE_ADD;
        if (j!= 5){
          PetscErrorPrintf("Number of inputs for solid boundary '%s' for group %d should be 5 not %d\n", SOLID_BC_TYPE_CHAR[solid->Gr_type[g]], g, j);
          SETERRABORT(PETSC_COMM_WORLD,PETSC_ERR_ARG_WRONG,"Error! Wrong number of inputs.");}
        ierr = PetscOptionsStringToScalar(data[2], &value); CHKERRQ(ierr);solid->Gr_value[g][0] = value; // Added Force X magnitude
        ierr = PetscOptionsStringToScalar(data[3], &value); CHKERRQ(ierr);solid->Gr_value[g][1] = value; // Added Force Y magnitude
        ierr = PetscOptionsStringToScalar(data[4], &value); CHKERRQ(ierr);solid->Gr_value[g][2] = value; // Added Force Z magnitude
        PetscPrintf(PETSC_COMM_WORLD,"  Solid boundary group %d: %s\n    F=(%g, %g, %g) \n", g, SOLID_BC_TYPE_CHAR[solid->Gr_type[g]], 
          (double)solid->Gr_value[g][0], (double)solid->Gr_value[g][1], (double)solid->Gr_value[g][2]);
      }
      else if (flg_fi) // FORCE_INSERT (Inserts a boundary force in replace of the force generated by the system)
      {
        solid->Gr_type[g] = FORCE_INSERT;
        if (j!= 5){
          PetscErrorPrintf("Number of inputs for solid boundary '%s' for group %d should be 5 not %d\n", SOLID_BC_TYPE_CHAR[solid->Gr_type[g]], g, j);
          SETERRABORT(PETSC_COMM_WORLD,PETSC_ERR_ARG_WRONG,"Error! Wrong number of inputs.");}
        ierr = PetscOptionsStringToScalar(data[2], &value); CHKERRQ(ierr); solid->Gr_value[g][0] = value; // Inserted Force X magnitude
        ierr = PetscOptionsStringToScalar(data[3], &value); CHKERRQ(ierr); solid->Gr_value[g][1] = value; // Inserted Force Y magnitude
        ierr = PetscOptionsStringToScalar(data[4], &value); CHKERRQ(ierr); solid->Gr_value[g][2] = value; // Inserted Force Z magnitude
        PetscPrintf(PETSC_COMM_WORLD,"  Solid boundary group %d: %s\n    F=(%g, %g, %g) \n", g, SOLID_BC_TYPE_CHAR[solid->Gr_type[g]], 
          (double)solid->Gr_value[g][0], (double)solid->Gr_value[g][1], (double)solid->Gr_value[g][2]);
      }
      else if (flg_df) // DIST_FIXED (Fixes the position of the bounadry)
      { 
        solid->Gr_type[g] = DIST_FIXED;
        if (j!= 2){
          PetscErrorPrintf("Number of inputs for solid boundary '%s' for group %d should be 2 not %d\n", SOLID_BC_TYPE_CHAR[solid->Gr_type[g]], g, j);
          SETERRABORT(PETSC_COMM_WORLD,PETSC_ERR_ARG_WRONG,"Error! Wrong number of inputs.");}
        solid->Gr_value[g][0] = 0.0;                    // Velocity to move point in X direction
        solid->Gr_value[g][1] = 0.0;                    // Velocity to move point in Y direction
        solid->Gr_value[g][2] = 0.0;                    // Velocity to move point in Z direction
        PetscPrintf(PETSC_COMM_WORLD,"  Solid boundary group %d: %s \n", g, SOLID_BC_TYPE_CHAR[solid->Gr_type[g]]);
      }
      else if (flg_ds) // DISTANCE SPEED BOUNDARY (x += Ub*dt, y += Vb*dt, z += Wb*dt) [Replaces the speed from fluid by the boundary speed]
      { 
        solid->Gr_type[g] = DIST_SPEED;
        if (j!= 5){
          PetscErrorPrintf("Number of inputs for solid boundary '%s' for group %d should be 5 not %d\n", SOLID_BC_TYPE_CHAR[solid->Gr_type[g]], g, j);
          SETERRABORT(PETSC_COMM_WORLD,PETSC_ERR_ARG_WRONG,"Error! Wrong number of inputs.");}
        ierr = PetscOptionsStringToScalar(data[2], &value); CHKERRQ(ierr); solid->Gr_value[g][0] = value; // Velocity to move points in X direction
        ierr = PetscOptionsStringToScalar(data[3], &value); CHKERRQ(ierr); solid->Gr_value[g][1] = value; // Velocity to move points in Y direction
        ierr = PetscOptionsStringToScalar(data[4], &value); CHKERRQ(ierr); solid->Gr_value[g][2] = value; // Velocity to move points in Z direction
        PetscPrintf(PETSC_COMM_WORLD,"  Solid boundary group %d: %s\n    Vel=(%g, %g, %g) \n", g, SOLID_BC_TYPE_CHAR[solid->Gr_type[g]], 
          (double)solid->Gr_value[g][0], (double)solid->Gr_value[g][1], (double)solid->Gr_value[g][2]);
      }
      else if (flg_dsxly) // DISTANCE SPEED X BOUNDARY AS A LINEAR FUNCTION IN Y (x += Ub(y)*dt where Ub(y) = A*y+B)
      { 
        solid->Gr_type[g] = DIST_SPEED_X_LINEAR_Y;
        if (j!= 4){
          PetscErrorPrintf("Number of inputs for solid boundary '%s' for group %d should be 4 not %d\n", SOLID_BC_TYPE_CHAR[solid->Gr_type[g]], g, j);
          SETERRABORT(PETSC_COMM_WORLD,PETSC_ERR_ARG_WRONG,"Error! Wrong number of inputs.");}
        ierr = PetscOptionsStringToScalar(data[2], &value); CHKERRQ(ierr); solid->Gr_value[g][0] = value; // A
        ierr = PetscOptionsStringToScalar(data[3], &value); CHKERRQ(ierr); solid->Gr_value[g][1] = value; // B     
        PetscPrintf(PETSC_COMM_WORLD,"  Solid boundary group %d: %s\n    Vel_x(y) = %g*y + %g \n", g, SOLID_BC_TYPE_CHAR[solid->Gr_type[g]], 
          (double)solid->Gr_value[g][0], (double)solid->Gr_value[g][1]);
      }
      else if (flg_fs) // FORCE_SPEED (Adds a boundary force in terms of a boundary speed in addition to the force generated by the system)
      {  
        solid->Gr_type[g] = FORCE_SPEED;
        if (j!= 9){
          PetscErrorPrintf("Number of inputs for solid boundary '%s' for group %d should be 9 not %d\n", SOLID_BC_TYPE_CHAR[solid->Gr_type[g]], g, j);
          SETERRABORT(PETSC_COMM_WORLD,PETSC_ERR_ARG_WRONG,"Error! Wrong number of inputs.");}
        ierr = PetscOptionsStringToScalar(data[2], &value); CHKERRQ(ierr); solid->Gr_value[g][0] = value; // Velocity to move point in X direction
        ierr = PetscOptionsStringToScalar(data[3], &value); CHKERRQ(ierr); solid->Gr_value[g][1] = value; // Velocity to move point in Y direction
        ierr = PetscOptionsStringToScalar(data[4], &value); CHKERRQ(ierr); solid->Gr_value[g][2] = value; // Velocity to move point in Z direction
        ierr = PetscOptionsStringToScalar(data[5], &value); CHKERRQ(ierr); solid->Gr_value[g][3] = value; // Initial displacement of fake points in X direction
        ierr = PetscOptionsStringToScalar(data[6], &value); CHKERRQ(ierr); solid->Gr_value[g][4] = value; // Initial displacement of fake points in Y direction
        ierr = PetscOptionsStringToScalar(data[7], &value); CHKERRQ(ierr); solid->Gr_value[g][5] = value; // Initial displacement of fake points in Z direction
        ierr = PetscOptionsStringToScalar(data[8], &value); CHKERRQ(ierr); solid->Gr_value[g][6] = value; // Spring constant for imaginary points
        PetscSNPrintf(solid->forces.BC_FS.File,sizeof(solid->forces.BC_FS.File),"%s/External_Force.txt",system->SYSOutputFolder);

        PetscPrintf(PETSC_COMM_WORLD,"  Solid boundary group %d: %s\n    Vel=(%g, %g, %g), Ds=(%g, %g, %g), and K=%lf\n", 
          g, SOLID_BC_TYPE_CHAR[solid->Gr_type[g]],  (double)solid->Gr_value[g][0], (double)solid->Gr_value[g][1], (double)solid->Gr_value[g][2], 
          (double)solid->Gr_value[g][3], (double)solid->Gr_value[g][4], (double)solid->Gr_value[g][5], (double)solid->Gr_value[g][6]);
      }
      else if (flg_sym) // Symmetry boundary
      {
        solid->Gr_type[g] = SYMMETRY;
        if (j!= 5){
          PetscErrorPrintf("Number of inputs for solid boundary '%s' for group %d should be 5 not %d\n", SOLID_BC_TYPE_CHAR[solid->Gr_type[g]], g, j);
          SETERRABORT(PETSC_COMM_WORLD,PETSC_ERR_ARG_WRONG,"Error! Wrong number of inputs.");}
        ierr = PetscOptionsStringToScalar(data[2], &value); CHKERRQ(ierr); solid->Gr_value[g][0] = value; // Symmetry either (0 or 1)
        ierr = PetscOptionsStringToScalar(data[3], &value); CHKERRQ(ierr); solid->Gr_value[g][1] = value; // Symmetry either (0 or 1)
        ierr = PetscOptionsStringToScalar(data[4], &value); CHKERRQ(ierr); solid->Gr_value[g][2] = value; // Symmetry either (0 or 1)
        // Normalizing the componenets
        if ((solid->Gr_value[g][0] + solid->Gr_value[g][1] + solid->Gr_value[g][2]) != 2){    
          PetscErrorPrintf("Symmetry boundary only works when the sum of the components is 2 it is now %lf\n", solid->Gr_value[g][0] + solid->Gr_value[g][1] + solid->Gr_value[g][2]);
          SETERRABORT(PETSC_COMM_WORLD,PETSC_ERR_ARG_WRONG,"Error! Wrong components for solid boundary SYMMETRY");}
      }
      else if (flg_fse) // FORCE_SPEED_ELLIPSE
      {  
        solid->Gr_type[g] = FORCE_SPEED_ELLIPSE;
        if (j!= 8){
          PetscErrorPrintf("Number of inputs for solid boundary '%s' for group %d should be 8 not %d\n", SOLID_BC_TYPE_CHAR[solid->Gr_type[g]], g, j);
          SETERRABORT(PETSC_COMM_WORLD,PETSC_ERR_ARG_WRONG,"Error! Wrong number of inputs.");}
        ierr = PetscOptionsStringToScalar(data[2], &value); CHKERRQ(ierr); solid->Gr_value[g][0] = value;       // A:         a major axis of ellipse (x)
        ierr = PetscOptionsStringToScalar(data[3], &value); CHKERRQ(ierr); solid->Gr_value[g][1] = value;       // B:         b minor axis of ellipse (y)
        ierr = PetscOptionsStringToScalar(data[4], &value); CHKERRQ(ierr); solid->Gr_value[g][2] = value;       // DTheta/Dt: Azumethal velocity
        ierr = PetscOptionsStringToScalar(data[5], &value); CHKERRQ(ierr); solid->Gr_value[g][3] = value;       // K:         Spring constant for imaginary points
        ierr = PetscOptionsStringToScalar(data[6], &value); CHKERRQ(ierr); solid->Gr_value[g][4] = value;       // Z:         z-plane upon which the ellipse resides
        ierr = PetscOptionsStringToScalar(data[7], &value); CHKERRQ(ierr); solid->Gr_value[g][5] = value;       // DTheta0:   Initial displacement of Azumethal angle from the initial position
        //ierr = PetscOptionsStringToScalar(data[5], &value); CHKERRQ(ierr); solid->Gr_value[g][3] = value;     // Dir: Azumethal Direction ccw (+1) or cw (-1)
        PetscSNPrintf(solid->forces.BC_FSE.File,sizeof(solid->forces.BC_FSE.File),"%s/External_Force_Ellipse.txt",system->SYSOutputFolder);

        PetscPrintf(PETSC_COMM_WORLD,"  Solid boundary group %d: %s\n    A=%g, B=%g, DTheta/Dt=%g, K=%g, z=%g, DTheta0=%g\n", 
          g, SOLID_BC_TYPE_CHAR[solid->Gr_type[g]], (double)solid->Gr_value[g][0], (double)solid->Gr_value[g][1], (double)solid->Gr_value[g][2],  (double)solid->Gr_value[g][3], (double)solid->Gr_value[g][4], 
          (double)solid->Gr_value[g][5]);
      }
      else if (flg_dse) // DIST_SPEED_ELLIPSE
      {
        solid->Gr_type[g] = DIST_SPEED_ELLIPSE;
        if (j!= 5){
          PetscErrorPrintf("Number of inputs for solid boundary '%s' for group %d should be 5 not %d\n", SOLID_BC_TYPE_CHAR[solid->Gr_type[g]], g, j);
          SETERRABORT(PETSC_COMM_WORLD,PETSC_ERR_ARG_WRONG,"Error! Wrong number of inputs.");}
        ierr = PetscOptionsStringToScalar(data[2], &value); CHKERRQ(ierr); solid->Gr_value[g][0] = value;       // A:         a major axis of ellipse (x)
        ierr = PetscOptionsStringToScalar(data[3], &value); CHKERRQ(ierr); solid->Gr_value[g][1] = value;       // B:         b minor axis of ellipse (y)
        ierr = PetscOptionsStringToScalar(data[4], &value); CHKERRQ(ierr); solid->Gr_value[g][2] = value;       // DTheta/Dt: Azumethal velocity

        PetscPrintf(PETSC_COMM_WORLD,"  Solid boundary group %d: %s\n    A=%g, B=%g, DTheta/Dt=%g\n", 
          g, SOLID_BC_TYPE_CHAR[solid->Gr_type[g]], (double)solid->Gr_value[g][0], (double)solid->Gr_value[g][1], (double)solid->Gr_value[g][2]);
      }
      else if (flg_af) // AXIS_FIXED
      {
        solid->Gr_type[g] = AXIS_FIXED;
        if (j!= 3){
          PetscErrorPrintf("Number of inputs for solid boundary '%s' for group %d should be 3 not %d\n", SOLID_BC_TYPE_CHAR[solid->Gr_type[g]], g, j);
          SETERRABORT(PETSC_COMM_WORLD,PETSC_ERR_ARG_WRONG,"Error! Wrong number of inputs.");}
        ierr = PetscOptionsStringToScalar(data[2], &value); CHKERRQ(ierr); solid->Gr_value[g][0] = value;       // Axis to fix (0:x, 1:y, z:2)
        if (solid->Gr_value[g][0] != 0 && solid->Gr_value[g][0] != 1 && solid->Gr_value[g][0] != 2){    
          PetscErrorPrintf("AXIS_FIXED boundary takes one input 0:x, 1:y, z:2 not %lf\n",solid->Gr_value[g][0]) ;
          SETERRABORT(PETSC_COMM_WORLD,PETSC_ERR_ARG_WRONG,"Error! Wrong component for solid boundary AXIS_FIXED");}

        PetscPrintf(PETSC_COMM_WORLD,"  Solid boundary group %d: %s = %d\n", g, SOLID_BC_TYPE_CHAR[solid->Gr_type[g]], (int)solid->Gr_value[g][0]);
      }
      else if (flg_fae) // FORCE_ADD_ELLIPSE
      {
        solid->Gr_type[g] = FORCE_ADD_ELLIPSE;
        if (j!= 6){
          PetscErrorPrintf("Number of inputs for solid boundary '%s' for group %d should be 6 not %d\n", SOLID_BC_TYPE_CHAR[solid->Gr_type[g]], g, j);
          SETERRABORT(PETSC_COMM_WORLD,PETSC_ERR_ARG_WRONG,"Error! Wrong number of inputs.");}
        ierr = PetscOptionsStringToScalar(data[2], &value); CHKERRQ(ierr); solid->Gr_value[g][0] = value;       // A:   a major axis of ellipse (x)
        ierr = PetscOptionsStringToScalar(data[3], &value); CHKERRQ(ierr); solid->Gr_value[g][1] = value;       // B:   b minor axis of ellipse (y)
        ierr = PetscOptionsStringToScalar(data[4], &value); CHKERRQ(ierr); solid->Gr_value[g][2] = value;       // Dir: Azumethal Direction ccw (+1) or cw (-1)
        ierr = PetscOptionsStringToScalar(data[5], &value); CHKERRQ(ierr); solid->Gr_value[g][3] = value;       // Mag: Magnitude of force
        if ( solid->Gr_value[g][2] != -1 && solid->Gr_value[g][2] != 1){    
          PetscErrorPrintf("FORCE_ADD_ELLIPSE boundary takes direction either -1 or 1 not %lf\n",solid->Gr_value[g][2]) ;
          SETERRABORT(PETSC_COMM_WORLD,PETSC_ERR_ARG_WRONG,"Error! Wrong component for solid boundary FORCE_ADD_ELLIPSE");}

        PetscPrintf(PETSC_COMM_WORLD,"  Solid boundary group %d: %s\n    A=%lf, B=%lf, Dir=%d, and Fb=%f\n", g, SOLID_BC_TYPE_CHAR[solid->Gr_type[g]], solid->Gr_value[g][0], solid->Gr_value[g][1], (int)solid->Gr_value[g][2], 
          solid->Gr_value[g][3]);
      }
      else 
      {    
        PetscErrorPrintf("Wrong type of input solid boundary for group %d\n", g);
        SETERRABORT(PETSC_COMM_WORLD,PETSC_ERR_ARG_WRONG,"Error! Wrong solid boundary");  
      }
      PetscStrToArrayDestroy(j, data);
    }
  }
  else
    PetscPrintf(PETSC_COMM_WORLD,"  No solid points boundaries found\n");

  return 0;
}

#endif